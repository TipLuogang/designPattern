由工厂对象决定创建出哪一种产品类的实例
简单工厂模式
    适合创建逻辑比较简单，创建的对象较少
    客户端只需要传入工厂类的参数，根据不同的参数，调用不同的逻辑，创建不同的对象

    优点：只需传入一个参数
    缺点：多个参数的职责放到一个方法里面，工厂职责相对比较重，增加新的产品时，需修改工厂类的判断逻辑，违背开闭原则
        不易于扩展过于复杂的产品结构（只能创建一个类型的产品-ICourse）

工厂方法模式
    定义一个创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行
    解决产品链越来越多的问题,产品链扩展的时候，不修改原有代码
    适用于：创建对象时，需要大量重复代码； 不需要传参，只需要关心对应的工厂，无须关心创建细节
        新加入产品时，符合开闭原则，提高了系统可扩展性
    缺点：产品多时，类的数量过多，增加了理解难度，系统结构复杂

抽象工厂
    支持更复杂的产品结构,解决产品链，产品族复杂情况
    每一个产品族必须有3个产品，这3个产品可以被多个工厂创建
    问题：不符合开闭原则，当新加一个产品时，每个工厂都需要修改，新增产品困难，层次结构复杂
    优点：具体产品在应用层代码隔离，无须关心创建细节
        将一个系列的产品族同一到一起创建
        扩展性非常强
